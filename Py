"""
Splunk Query Executor (Fully Configured Version)
Author: Assistant
Date: 2023-08-21
"""

import requests
import argparse
import time
import xml.etree.ElementTree as ET
from urllib3.exceptions import InsecureRequestWarning

# ==============================
# CONFIGURATION SECTION - EDIT THESE VALUES
# ==============================

# Splunk REST API Configuration
SPLUNK_REST_URL = "https://splunk-rest.ops.tiaa-cref.org/services"
SPLUNK_AUTH_URL = "https://splunk-auth.ops.tiaa-cref.org/services/auth/login"

# User Credentials
SPLUNK_USERNAME = "kalajo"
SPLUNK_PASSWORD = "Qwer"

# SSL Configuration (Set verify_ssl=True in production with valid certificates)
VERIFY_SSL = False
CERT_PATH = "C:/path/to/your/certificate.pem"  # Only needed if VERIFY_SSL=True

# Search Configuration
DEFAULT_OUTPUT_MODE = "csv"  # csv, json, xml
SEARCH_TIMEOUT = 300  # seconds
POLL_INTERVAL = 2  # seconds between status checks

# ==============================
# END OF CONFIGURATION
# ==============================

# Suppress SSL warnings if verification is disabled
if not VERIFY_SSL:
    requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

class SplunkQueryExecutor:
    def __init__(self):
        self.session_key = None
        self._authenticate()

    def _authenticate(self):
        """Authenticate to Splunk using dedicated auth endpoint"""
        auth_data = {
            'username': SPLUNK_USERNAME,
            'password': SPLUNK_PASSWORD
        }

        try:
            response = requests.post(
                SPLUNK_AUTH_URL,
                data=auth_data,
                verify=CERT_PATH if VERIFY_SSL else False,
                timeout=10
            )
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            raise ConnectionError(f"Authentication failed: {str(e)}")

        # Parse XML response for session key
        root = ET.fromstring(response.content)
        self.session_key = root.find('.//sessionKey').text
        if not self.session_key:
            raise ValueError("Session key not found in authentication response")

    def _execute_search(self, search_query, is_saved_search=False):
        """Create and execute a search job"""
        headers = {
            'Authorization': f'Splunk {self.session_key}',
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        # Build the appropriate search command
        query = f'| savedsearch {search_query}' if is_saved_search else search_query
        payload = {
            'search': query,
            'output_mode': DEFAULT_OUTPUT_MODE,
            'adhoc_search_level': 'verbose'
        }

        try:
            response = requests.post(
                f"{SPLUNK_REST_URL}/search/jobs",
                headers=headers,
                data=payload,
                verify=CERT_PATH if VERIFY_SSL else False,
                timeout=SEARCH_TIMEOUT
            )
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            raise RuntimeError(f"Search initiation failed: {str(e)}")

        # Parse response for search ID
        root = ET.fromstring(response.content)
        search_id = root.find('.//sid').text
        return search_id

    def _wait_for_completion(self, search_id):
        """Monitor search job completion with timeout"""
        headers = {'Authorization': f'Splunk {self.session_key}'}
        status_url = f"{SPLUNK_REST_URL}/search/jobs/{search_id}"
        
        start_time = time.time()
        
        while (time.time() - start_time) < SEARCH_TIMEOUT:
            try:
                response = requests.get(
                    status_url,
                    headers=headers,
                    verify=CERT_PATH if VERIFY_SSL else False
                )
                response.raise_for_status()
                
                root = ET.fromstring(response.content)
                is_done = root.find('.//s:key[@name="isDone"]', {'s': 'http://dev.splunk.com/ns/rest'})
                
                if is_done.text == '1':
                    return
                
                time.sleep(POLL_INTERVAL)
                
            except requests.exceptions.RequestException as e:
                raise RuntimeError(f"Status check failed: {str(e)}")

        raise TimeoutError("Search job timed out")

    def _get_results(self, search_id):
        """Retrieve search results"""
        headers = {'Authorization': f'Splunk {self.session_key}'}
        results_url = f"{SPLUNK_REST_URL}/search/jobs/{search_id}/results"
        
        params = {
            'output_mode': DEFAULT_OUTPUT_MODE,
            'count': 0  # Get all results
        }

        try:
            response = requests.get(
                results_url,
                headers=headers,
                params=params,
                verify=CERT_PATH if VERIFY_SSL else False,
                timeout=SEARCH_TIMEOUT
            )
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            raise RuntimeError(f"Results retrieval failed: {str(e)}")

        return response.text

    def execute(self, query, output_file, is_saved_search=False):
        """Full query execution workflow"""
        search_id = self._execute_search(query, is_saved_search)
        print(f"🚀 Search job {search_id} created")
        self._wait_for_completion(search_id)
        print("✅ Search completed successfully")
        
        results = self._get_results(search_id)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(results)
        print(f"📁 Results saved to {output_file}")

def main():
    parser = argparse.ArgumentParser(description='Execute Splunk queries')
    query_group = parser.add_mutually_exclusive_group(required=True)
    query_group.add_argument('--query', help='Raw SPL query to execute')
    query_group.add_argument('--saved-search', help='Name of saved search to execute')
    parser.add_argument('--output', required=True, help='Output file path')
    
    args = parser.parse_args()

    try:
        executor = SplunkQueryExecutor()
        
        if args.query:
            executor.execute(args.query, args.output)
        else:
            executor.execute(args.saved_search, args.output, is_saved_search=True)
            
    except Exception as e:
        print(f"❌ Critical error: {str(e)}")
        exit(1)

if __name__ == "__main__":
    main()
