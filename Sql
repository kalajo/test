# 1. Increase server connection timeout (to handle slow requests)
server.connection-timeout=60s  # Adjust to suit your needs (e.g., 120s)

# 2. Increase maximum file size and request size (even if you're not uploading files, large payloads could cause issues)
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# 3. HTTP keep-alive settings (to prevent premature connection closure)
server.http2.enabled=true
server.tomcat.max-threads=200

# 4. Enable CORS (if the issue might be related to cross-origin resource sharing)
# Add specific origin if needed, or use "*" for all origins (not recommended for production)
spring.mvc.cors.allowed-origins=*
spring.mvc.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.mvc.cors.allowed-headers=Authorization,Content-Type
spring.mvc.cors.allow-credentials=true
spring.mvc.cors.max-age=3600







import org.owasp.esapi.ESAPI;
import org.owasp.esapi.Encoder;
import org.owasp.esapi.codecs.MySQLCodec;
import org.owasp.esapi.codecs.OracleCodec;
import org.owasp.esapi.codecs.LDAPCodec;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@CrossOrigin(maxAge = 3600)
@RestController
public class LoginController {

    private final Encoder encoder = ESAPI.encoder(); // Initialize ESAPI encoder
    private final MySQLCodec mySQLCodec = new MySQLCodec(); // MySQL codec for SQL sanitization
    private final LDAPCodec ldapCodec = new LDAPCodec(); // LDAP codec for LDAP sanitization

    @PostMapping("/api/login")
    public ResponseEntity<?> login(@RequestBody User user) {
        try {
            // Sanitize inputs for LDAP and SQL using proper codecs
            String sanitizedUsernameForLDAP = encoder.encodeForLDAP(ldapCodec, user.getUsername());
            String sanitizedPasswordForLDAP = encoder.encodeForLDAP(ldapCodec, user.getPassword());

            log.info("Sanitized Username for LDAP: {}", sanitizedUsernameForLDAP);

            // Sanitize SQL input
            String sqlSafeUsername = encoder.encodeForSQL(mySQLCodec, user.getUsername());
            String sqlSafePassword = encoder.encodeForSQL(mySQLCodec, user.getPassword());

            log.info("SQL-Safe Username: {}", sqlSafeUsername);

            // Perform LDAP-based authentication with sanitized inputs
            if (authenticateAgainstLdap(sanitizedUsernameForLDAP, sanitizedPasswordForLDAP)) {
                return ResponseEntity.ok("Login successful");
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid credentials");
            }
        } catch (Exception ex) {
            log.error("Error occurred during login", ex);
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Login failed");
        }
    }

    // Dummy method simulating LDAP authentication
    private boolean authenticateAgainstLdap(String username, String password) {
        // Implement LDAP authentication here with the sanitized username and password
        return "user".equals(username) && "password".equals(password);  // Replace with actual LDAP logic
    }
}




















# === OWASP ESAPI Configuration ===

# Default Encoder and Decoder for ESAPI
Encoder.Default=org.owasp.esapi.reference.DefaultEncoder
Decoder.Default=org.owasp.esapi.reference.DefaultDecoder

# Default Validator for inputs
Validator.Default=org.owasp.esapi.reference.DefaultValidator

# === Security Configuration ===

# Character encoding for all input/output operations
ESAPI.SecurityConfiguration.DefaultCharacterEncoding=UTF-8

# Default locale
ESAPI.SecurityConfiguration.DefaultLocale=en_US

# Allow canonicalization (set to false to prevent encoding issues)
ESAPI.SecurityConfiguration.AllowMultipleEncoding=false
ESAPI.SecurityConfiguration.AllowMixedEncoding=false

# Maximum allowed size for input to prevent large data attacks
ESAPI.SecurityConfiguration.MaxInputSize=10000

# Encryption and hashing configuration
ESAPI.SecurityConfiguration.MasterKey="YourMasterKeyHere"  # Change this to a real key
ESAPI.SecurityConfiguration.EncryptionAlgorithm=AES
ESAPI.SecurityConfiguration.HashAlgorithm=SHA-256

# Encryption and hashing iterations
ESAPI.SecurityConfiguration.EncryptionKeyLength=128
ESAPI.SecurityConfiguration.HashIterations=1000
ESAPI.SecurityConfiguration.EncryptionIterations=1000

# === LDAP/SQL Settings ===

# LDAP Sanitization
LDAP.AllowedChars=A-Za-z0-9
LDAP.MaxInputLength=100  # Set this based on your LDAP requirements

# SQL Sanitization - Adjust based on the database used (e.g., MySQL, Oracle)
SQL.AllowedChars=A-Za-z0-9_-
SQL.MaxInputLength=255
SQL.DatabaseCodec=MySQLCodec  # Change this to the codec of your database (e.g., OracleCodec, MySQLCodec)

# === Logging Configuration ===

# Logger settings
Logger=org.owasp.esapi.reference.JavaLogFactory
LogLevel=ERROR
LogEncodingRequired=false
LogApplicationName=MyApp
LogServerIP=localhost
LogServerName=localhost

# === Intrusion Detection ===

# Enable or disable intrusion detection
IntrusionDetector.Enabled=true

# Thresholds for detecting multiple failed attempts (adjust as needed)
IntrusionDetector.UserThreshold=5
IntrusionDetector.IPThreshold=5
IntrusionDetector.AppThreshold=5

# === Validator Settings ===

# Optional: Path to custom validation properties (for regex-based validation rules)
Validator.ConfigurationFile=validation.properties

# === File and Locale Settings ===

# Resource directories for ESAPI
ESAPI.SecurityConfiguration.FilePath=esapi
ESAPI.SecurityConfiguration.ResourceDirectory=src/main/resources

# Secure random algorithm (adjust if needed)
ESAPI.SecurityConfiguration.SecureRandomAlgorithm=SHA1PRNG




Validator.Type.Username=^[a-zA-Z0-9._-]{3,}$   # Username must have at least 3 characters
Validator.Type.Password=^.{8,}$                # Password must be at least 8 characters














