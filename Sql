# 1. Increase server connection timeout (to handle slow requests)
server.connection-timeout=60s  # Adjust to suit your needs (e.g., 120s)

# 2. Increase maximum file size and request size (even if you're not uploading files, large payloads could cause issues)
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# 3. HTTP keep-alive settings (to prevent premature connection closure)
server.http2.enabled=true
server.tomcat.max-threads=200

# 4. Enable CORS (if the issue might be related to cross-origin resource sharing)
# Add specific origin if needed, or use "*" for all origins (not recommended for production)
spring.mvc.cors.allowed-origins=*
spring.mvc.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.mvc.cors.allowed-headers=Authorization,Content-Type
spring.mvc.cors.allow-credentials=true
spring.mvc.cors.max-age=3600


public boolean processQueryResult(QueryResult queryResult) {
    List<Object> columnClasses = queryResult.getColumnClass(); // Get the column classes from queryResult
    FormatType[] formatTypes = new FormatType[columnClasses.size()]; // Initialize formatTypes array

    // Iterate through columnClasses to check if they are safe to cast
    for (int i = 0; i < columnClasses.size(); i++) {
        Object columnClass = columnClasses.get(i);

        // Check if it's safe to cast the object to Class
        if (columnClass instanceof Class<?>) {
            // Proceed with safe casting
            formatTypes[i] = FormatType.TEXT; // You can adjust this logic as needed
        } else {
            // Unsafe to cast, log the issue and return false
            System.out.println("Unsafe casting detected at index " + i);
            return false;
        }
    }

    // If everything is safe, proceed with further operations
    QueryResultToExcel resultToExcel = new QueryResultToExcel(queryResult, formatTypes, "Results");

    // Return true to indicate success
    return true;
}


import org.owasp.encoder.Encode;
import java.sql.SQLException;

@Slf4j
@CrossOrigin(maxAge = 3600)
@RestController
public class LoginController {

    private EnvRoutingDataSource dataSourceRouting = EnvRoutingDataSource.getInstance();

    @Autowired
    private AuthenticationService authenticationService;

    @PostMapping("/api/login")
    public ResponseEntity<?> login(@RequestBody User user) {

        try {
            // Sanitize and encode the selected environment, username, and password using OWASP encoder
            String sanitizedEnv = Encode.forJava(user.getSelectedEnv());
            String sanitizedUsername = Encode.forJava(user.getUsername());
            String sanitizedPassword = Encode.forJava(user.getPassword());

            // Check if the sanitized environment exists in the data source
            if (dataSourceRouting.getDataSourceMapForEnv(sanitizedEnv)) {
                // Create a new sanitized User object or modify the existing one
                User sanitizedUser = new User(sanitizedUsername, sanitizedPassword, sanitizedEnv);
                
                // Pass the sanitized user to the authentication service
                return authenticationService.authenticateUser(sanitizedUser);
            } else {
                return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body("Selected DB not available");
            }

        } catch (SQLException ex) {
            log.error("Database error: {}", ex.getMessage(), ex);
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Selected DB not available");
        } catch (Exception ex) {
            log.error("An unexpected error occurred: {}", ex.getMessage(), ex);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred");
        }
    }
}


